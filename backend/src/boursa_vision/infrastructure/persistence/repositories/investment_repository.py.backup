"""
SQLAlchemy Investment Repository Implementation
===============================================

SQLAlchemy implementation of the investment repository interface.
"""

from typing import List, Optional
from uuid import UUID

from sqlalchemy import select, delete as sql_delete, func
from sqlalchemy.ext.asyncio import AsyncSession

from ....domain.entities.investment import Investment
from ....domain.repositories.investment_repository import IInvestmentRepository
from ..models.investment import InvestmentModel
from ..sqlalchemy.database import get_db_session


class SimpleInvestmentMapper:
    """Simple mapper for Investment domain entity ↔ InvestmentModel."""

    def to_domain(self, model: InvestmentModel) -> Investment:
        """Convert SQLAlchemy InvestmentModel to domain Investment."""
        from boursa_vision.domain.entities.investment import MarketCap, InvestmentSector, InvestmentType
        from boursa_vision.domain.value_objects.money import Currency
        
        # Mapper market_cap numérique vers enum MarketCap
        market_cap_enum = MarketCap.LARGE  # Valeur par défaut
        if model.market_cap is not None:
            market_cap_value = float(str(model.market_cap))
            # Mapping inverse des valeurs numériques vers enum
            if market_cap_value < 0.05:  # < $50M
                market_cap_enum = MarketCap.NANO
            elif market_cap_value < 0.3:  # $50M - $300M
                market_cap_enum = MarketCap.MICRO
            elif market_cap_value < 2:  # $300M - $2B
                market_cap_enum = MarketCap.SMALL
            elif market_cap_value < 10:  # $2B - $10B
                market_cap_enum = MarketCap.MID
            elif market_cap_value < 200:  # $10B - $200B
                market_cap_enum = MarketCap.LARGE
            else:  # > $200B
                market_cap_enum = MarketCap.MEGA

        # Mapper sector string vers enum
        sector_enum = InvestmentSector.TECHNOLOGY  # Valeur par défaut
        if model.sector:
            try:
                sector_enum = InvestmentSector(model.sector)
            except ValueError:
                sector_enum = InvestmentSector.TECHNOLOGY

        # Créer l'entité domain avec les bons paramètres
        return Investment.create(
            symbol=model.symbol,
            name=model.name,
            investment_type=InvestmentType.STOCK,  # Valeur par défaut pour les tests
            sector=sector_enum,
            market_cap=market_cap_enum,
            currency=Currency.USD,  # Valeur par défaut pour les tests
            exchange=model.exchange,
            isin=None,  # Non stocké dans le modèle actuel
        )

    def to_persistence(self, entity: Investment) -> InvestmentModel:
        """Convert domain Investment to SQLAlchemy InvestmentModel."""
        # Convertir market_cap enum vers une valeur numérique
        market_cap_value = 50.0  # Valeur par défaut
        if hasattr(entity, 'market_cap') and entity.market_cap is not None:
            market_cap = entity.market_cap
            # Mapper les enum vers des valeurs numériques approximatives
            market_cap_mapping = {
                'NANO': 0.025,   # ~$25M (< 50M)
                'MICRO': 0.175,  # ~$175M (50M - 300M) 
                'SMALL': 1.15,   # ~$1.15B (300M - 2B)
                'MID': 6.0,      # ~$6B (2B - 10B)
                'LARGE': 100.0,  # ~$100B (10B - 200B)
                'MEGA': 500.0,   # ~$500B (> 200B)
            }
            market_cap_value = market_cap_mapping.get(market_cap.value, 100.0)

        return InvestmentModel(
            symbol=entity.symbol,
            name=entity.name,
            exchange=entity.exchange,
            sector=entity.sector.value if hasattr(entity.sector, "value") else str(entity.sector),
            industry="Software",  # Valeur par défaut
            market_cap=market_cap_value,
            description=None,  # L'entité n'a pas ce champ
        )


class SQLAlchemyInvestmentRepository(IInvestmentRepository):
    """SQLAlchemy implementation of investment repository."""

    def __init__(self, session: Optional[AsyncSession] = None):
        self._mapper = SimpleInvestmentMapper()
        self._session = session  # Optional injected session for testing

    async def find_by_symbol(self, symbol: str) -> Optional[Investment]:
        """Find investment by symbol."""
        if self._session:
            # Use injected session (testing mode)
            stmt = select(InvestmentModel).where(InvestmentModel.symbol == symbol)
            result = await self._session.execute(stmt)
            model = result.scalar_one_or_none()
            return self._mapper.to_domain(model) if model else None
        else:
            # Use get_db_session (production mode)
            async with get_db_session() as session:
                stmt = select(InvestmentModel).where(InvestmentModel.symbol == symbol)
                result = await session.execute(stmt)
                model = result.scalar_one_or_none()
                return self._mapper.to_domain(model) if model else None

    async def find_by_id(self, investment_id: str) -> Optional[Investment]:
        """Find investment by ID."""
        if self._session:
            # Use injected session (testing mode)
            stmt = select(InvestmentModel).where(InvestmentModel.id == investment_id)
            result = await self._session.execute(stmt)
            model = result.scalar_one_or_none()
            return self._mapper.to_domain(model) if model else None
        else:
            # Use get_db_session (production mode)
            async with get_db_session() as session:
                stmt = select(InvestmentModel).where(InvestmentModel.id == investment_id)
                result = await session.execute(stmt)
                model = result.scalar_one_or_none()
                return self._mapper.to_domain(model) if model else None

    async def find_by_exchange(self, exchange: str) -> List[Investment]:
        """Find investments by exchange."""
        if self._session:
            # Use injected session (testing mode)
            stmt = select(InvestmentModel).where(InvestmentModel.exchange == exchange)
            result = await self._session.execute(stmt)
            models = result.scalars().all()
            return [self._mapper.to_domain(model) for model in models]
        else:
            # Use get_db_session (production mode)
            async with get_db_session() as session:
                stmt = select(InvestmentModel).where(InvestmentModel.exchange == exchange)
                result = await session.execute(stmt)
                models = result.scalars().all()
                return [self._mapper.to_domain(model) for model in models]

    async def find_by_sector(self, sector: str) -> List[Investment]:
        """Find investments by sector."""
        if self._session:
            # Use injected session (testing mode)
            stmt = select(InvestmentModel).where(InvestmentModel.sector == sector)
            result = await self._session.execute(stmt)
            models = result.scalars().all()
            return [self._mapper.to_domain(model) for model in models]
        else:
            # Use get_db_session (production mode)
            async with get_db_session() as session:
                stmt = select(InvestmentModel).where(InvestmentModel.sector == sector)
                result = await session.execute(stmt)
                models = result.scalars().all()
                return [self._mapper.to_domain(model) for model in models]

    async def find_all_active(self) -> List[Investment]:
        """Find all active investments."""
        # Pour l'instant, on retourne tous les investments car le modèle n'a pas de champ 'active'
        stmt = select(InvestmentModel)
        result = await self._session.execute(stmt)
        models = result.scalars().all()

        return [self._mapper.to_domain(model) for model in models]

    async def save(self, investment: Investment) -> Investment:
        """Save investment to database."""
        from sqlalchemy import delete as sql_delete
        
        # Vérifier si l'investment existe déjà
        stmt = select(InvestmentModel).where(InvestmentModel.symbol == investment.symbol)
        result = await self._session.execute(stmt)
        existing_model = result.scalar_one_or_none()

        if existing_model:
            # Supprimer l'ancien avec DELETE SQL direct
            delete_stmt = sql_delete(InvestmentModel).where(
                InvestmentModel.symbol == investment.symbol
            )
            await self._session.execute(delete_stmt)
            await self._session.flush()

        # Créer un nouvel investment
        model = self._mapper.to_persistence(investment)
        self._session.add(model)
        await self._session.flush()
        return self._mapper.to_domain(model)

    async def find_by_portfolio_id(self, portfolio_id: UUID) -> List[Investment]:
        """Find investments by portfolio ID."""
        # Pour l'instant, retourner une liste vide car nous n'avons pas la relation dans le modèle
        _ = portfolio_id  # Ignorer le paramètre pour l'instant
        return []

    async def exists(self, investment_id: UUID) -> bool:
        """Check if investment exists by ID."""
        if self._session:
            # Use injected session (testing mode)
            stmt = select(func.count(InvestmentModel.id)).where(InvestmentModel.id == investment_id)
            result = await self._session.execute(stmt)
            count = result.scalar()
            return (count or 0) > 0
        else:
            # Use get_db_session (production mode)
            async with get_db_session() as session:
                stmt = select(func.count(InvestmentModel.id)).where(InvestmentModel.id == investment_id)
                result = await session.execute(stmt)
                count = result.scalar()
                return (count or 0) > 0

    async def find_all(self, offset: int = 0, limit: int = 100) -> List[Investment]:
        """Find all investments with pagination."""
        if self._session:
            # Use injected session (testing mode)
            stmt = select(InvestmentModel).offset(offset).limit(limit)
            result = await self._session.execute(stmt)
            models = result.scalars().all()
            return [self._mapper.to_domain(model) for model in models]
        else:
            # Use get_db_session (production mode)
            async with get_db_session() as session:
                stmt = select(InvestmentModel).offset(offset).limit(limit)
                result = await session.execute(stmt)
                models = result.scalars().all()
                return [self._mapper.to_domain(model) for model in models]

    async def find_all(self) -> List[Investment]:
        """Find all investments (alias for find_all_active)."""
        return await self.find_all_active()
    
    async def find_by_market_cap(self, market_cap: str) -> List[Investment]:
        """Find investments by market cap."""
        # Convertir l'enum en valeur numérique approximative
        market_cap_mapping = {
            'NANO': 0.05,
            'MICRO': 0.25,
            'SMALL': 2.0,
            'MID': 10.0,
            'LARGE': 50.0,
            'MEGA': 500.0,
        }
        
        target_value = market_cap_mapping.get(market_cap, 50.0)
        # Recherche avec une marge de tolérance
        stmt = select(InvestmentModel).where(
            InvestmentModel.market_cap.between(target_value * 0.1, target_value * 10)
        )
        result = await self._session.execute(stmt)
        models = result.scalars().all()

        return [self._mapper.to_domain(model) for model in models]
    
    async def search_by_name(self, name_pattern: str) -> List[Investment]:
        """Search investments by name pattern."""
        stmt = select(InvestmentModel).where(
            InvestmentModel.name.ilike(f"%{name_pattern}%")
        )
        result = await self._session.execute(stmt)
        models = result.scalars().all()

        return [self._mapper.to_domain(model) for model in models]

    async def delete(self, investment: Investment) -> None:
        """Delete investment."""
        if self._session:
            # Use injected session (testing mode)
            stmt = sql_delete(InvestmentModel).where(InvestmentModel.symbol == investment.symbol)
            await self._session.execute(stmt)
            await self._session.flush()
        else:
            # Use get_db_session (production mode)
            async with get_db_session() as session:
                stmt = sql_delete(InvestmentModel).where(InvestmentModel.symbol == investment.symbol)
                await session.execute(stmt)
                await session.flush()
