# Backend BoursaVision ‚Äî Instructions Copilot

## Architecture Clean Architecture (respecter strictement)

### Structure des couches
```
backend/src/boursa_vision/
‚îú‚îÄ‚îÄ domain/                    # üèõÔ∏è COUCHE DOMAINE (Pure business logic)
‚îÇ   ‚îú‚îÄ‚îÄ entities/             # Agr√©gats & entit√©s (Portfolio, Investment, User, MarketData)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py          # AggregateRoot, Entity, DomainEvent
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolio.py     # Portfolio, Position, RiskLimits, PerformanceMetrics
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ investment.py    # Investment, InvestmentType, MarketCap, TechnicalData
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py          # User, UserRole + events
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ market_data.py   # MarketData, Timeframe, DataSource
‚îÇ   ‚îú‚îÄ‚îÄ value_objects/        # Objets valeur immutables
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ money.py         # Money, Currency
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ price.py         # Price
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signal.py        # Signal, SignalAction, ConfidenceScore
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ instruments.py   # Stock, Bond, ETF
‚îÇ   ‚îú‚îÄ‚îÄ events/              # √âv√©nements m√©tier
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolio_events.py  # PortfolioCreatedEvent, InvestmentAddedEvent
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_events.py       # UserCreatedEvent, UserDeactivatedEvent
‚îÇ   ‚îú‚îÄ‚îÄ repositories/        # Interfaces abstraites (contrats)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base_repository.py   # IBaseRepository[T]
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolio_repository.py  # IPortfolioRepository
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_repository.py      # IUserRepository
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ investment_repository.py # IInvestmentRepository
‚îÇ   ‚îî‚îÄ‚îÄ services/            # Services m√©tier complexes
‚îÇ       ‚îú‚îÄ‚îÄ risk_calculator.py      # RiskCalculatorService, RiskMetrics
‚îÇ       ‚îú‚îÄ‚îÄ performance_analyzer.py # PerformanceAnalyzerService
‚îÇ       ‚îî‚îÄ‚îÄ portfolio_allocation_service.py # AllocationStrategy
‚îÇ
‚îú‚îÄ‚îÄ application/              # üöÄ COUCHE APPLICATION (Use cases & orchestration)
‚îÇ   ‚îú‚îÄ‚îÄ commands/            # Commandes CQRS (write operations)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolio/       # CreatePortfolioCommand, AddInvestmentToPortfolioCommand
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ investment/      # CreateInvestmentCommand, UpdateInvestmentPriceCommand
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signal/          # GenerateSignalCommand
‚îÇ   ‚îú‚îÄ‚îÄ queries/             # Requ√™tes CQRS (read operations)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolio/       # GetUserPortfoliosQuery, AnalyzePortfolioQuery
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ investment/      # FindInvestmentsQuery, GetMarketDataQuery
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ signal/          # GetSignalsQuery, GetTechnicalAnalysisQuery
‚îÇ   ‚îú‚îÄ‚îÄ services/            # Services applicatifs (orchestration)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ technical_analyzer.py  # TechnicalAnalyzer (coordonne domain services)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ signal_generator.py    # SignalGenerator
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authentication_service.py # AuthenticationService
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ jwt_service.py         # JWTService, token management
‚îÇ   ‚îú‚îÄ‚îÄ dtos/                # Data Transfer Objects (API contracts)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py      # PortfolioDTO, InvestmentDTO, MoneyDTO, SignalDTO
‚îÇ   ‚îú‚îÄ‚îÄ mappers.py           # Entity ‚Üî DTO mappers
‚îÇ   ‚îî‚îÄ‚îÄ container.py         # ApplicationContainer (DI)
‚îÇ
‚îî‚îÄ‚îÄ infrastructure/           # üîß COUCHE INFRASTRUCTURE (Adapters externes)
    ‚îú‚îÄ‚îÄ persistence/         # Acc√®s aux donn√©es
    ‚îÇ   ‚îú‚îÄ‚îÄ models/          # SQLAlchemy models
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py      # Base, DatabaseMixin
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolios.py  # Portfolio, Position (tables)
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.py       # User (table)
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ investment.py  # InvestmentModel (table)
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ market_data.py # MarketData, TechnicalIndicator (TimescaleDB)
    ‚îÇ   ‚îú‚îÄ‚îÄ repositories/    # Impl√©mentations concr√®tes
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_repository.py      # SQLAlchemyUserRepository
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolio_repository.py # SQLAlchemyPortfolioRepository
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ investment_repository.py # SQLAlchemyInvestmentRepository
    ‚îÇ   ‚îú‚îÄ‚îÄ mappers.py       # Entity ‚Üî Model mappers (Domain ‚Üî SQLAlchemy)
    ‚îÇ   ‚îî‚îÄ‚îÄ database.py      # Session management, TimescaleDB config
    ‚îú‚îÄ‚îÄ web/                 # API HTTP
    ‚îÇ   ‚îú‚îÄ‚îÄ main.py          # FastAPI app factory
    ‚îÇ   ‚îú‚îÄ‚îÄ dependencies.py  # DI container, auth dependencies
    ‚îÇ   ‚îú‚îÄ‚îÄ routers/         # API endpoints
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ portfolio.py   # /api/v1/portfolios
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ investments.py # /api/v1/investments
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ market_data.py # /api/v1/market-data
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.py        # /api/v1/auth (login, register, refresh)
    ‚îÇ   ‚îú‚îÄ‚îÄ middleware.py    # CORS, Security, Logging, RateLimit
    ‚îÇ   ‚îî‚îÄ‚îÄ exceptions.py    # API exceptions & handlers
    ‚îî‚îÄ‚îÄ background/          # T√¢ches asynchrones
        ‚îú‚îÄ‚îÄ celery_app.py    # Configuration Celery + Redis
        ‚îú‚îÄ‚îÄ tasks.py         # T√¢ches d'archivage, notifications
        ‚îî‚îÄ‚îÄ market_data_archiver.py # Archivage TimescaleDB
```

## R√®gles de d√©pendances (STRICTES)

### üö´ Interdictions absolues
- **Domain** ne d√©pend de RIEN (ni Application, ni Infrastructure)
- **Application** d√©pend UNIQUEMENT de Domain
- **Infrastructure** peut d√©pendre de Domain et Application
- Jamais d'imports circulaires entre couches
- Jamais de `from infrastructure import` dans domain/
- Jamais de mod√®les SQLAlchemy dans domain/ ou application/

### ‚úÖ Patterns obligatoires
- **Repository Pattern** : Interfaces dans Domain, impl√©mentations dans Infrastructure
- **CQRS** : Commands (write) et Queries (read) s√©par√©es
- **Domain Events** : Communication via √©v√©nements dans les agr√©gats
- **Value Objects** : Immutables pour Money, Price, Currency
- **Aggregate Root** : Gestion des √©v√©nements m√©tier
- **Unit of Work** : Transactions coh√©rentes multi-agr√©gats

## Technologies & Outils

### Stack technique
- **Python** : 3.11+ avec type hints stricts
- **FastAPI** : Async API avec validation Pydantic
- **SQLAlchemy** : 2.0+ async ORM 
- **PostgreSQL + TimescaleDB** : Base principale + time-series
- **Redis** : Cache + sessions Celery
- **Celery** : T√¢ches background (archivage, notifications)
- **Poetry** : Gestion d√©pendances

### Outils qualit√© code
```bash
# Linting & formatage (ordre d'ex√©cution)
poetry run black src/ tests/           # Formatage code
poetry run isort src/ tests/           # Tri imports
poetry run flake8 src/ tests/          # Linting style
poetry run mypy src/                   # V√©rification types

# Tests & couverture
poetry run pytest -v                   # Tests unitaires
poetry run pytest --cov=src --cov-report=html  # Coverage HTML
poetry run pytest tests/integration/   # Tests d'int√©gration
poetry run pytest tests/e2e/          # Tests end-to-end
```

### Configuration pytest.ini (respecter)
```ini
[pytest]
testpaths = tests
pythonpath = src
addopts = -v --tb=short --strict-config --maxfail=5
```

## Patterns d'impl√©mentation

### Entit√©s Domain (exemple Portfolio)
```python
from dataclasses import dataclass
from uuid import UUID, uuid4
from ..events import PortfolioCreatedEvent
from ..value_objects import Money, Currency
from .base import AggregateRoot

@dataclass
class Portfolio(AggregateRoot):
    id: UUID = field(default_factory=uuid4)
    name: str
    user_id: UUID
    base_currency: Currency
    positions: List[Position] = field(default_factory=list)
    
    def add_investment(self, symbol: str, quantity: int, price: Money) -> None:
        """Ajouter un investissement au portefeuille."""
        # Business logic ici
        self._add_domain_event(InvestmentAddedEvent(portfolio_id=self.id, symbol=symbol))
```

### Repository Interface (Domain)
```python
from abc import ABC, abstractmethod
from typing import List, Optional
from uuid import UUID
from .base_repository import IBaseRepository

class IPortfolioRepository(IBaseRepository[Portfolio], ABC):
    @abstractmethod
    async def find_by_user_id(self, user_id: UUID) -> List[Portfolio]:
        """Trouver tous les portfolios d'un utilisateur."""
        
    @abstractmethod  
    async def find_by_name(self, name: str, user_id: UUID) -> Optional[Portfolio]:
        """Trouver un portfolio par nom pour un utilisateur."""
```

### Repository Implementation (Infrastructure)
```python
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from ...domain.repositories.portfolio_repository import IPortfolioRepository
from ...domain.entities.portfolio import Portfolio as DomainPortfolio
from .models.portfolios import Portfolio
from .mappers import PortfolioMapper

class SQLAlchemyPortfolioRepository(IPortfolioRepository):
    def __init__(self, session: AsyncSession):
        self._session = session
        self._mapper = PortfolioMapper()
    
    async def save(self, entity: DomainPortfolio) -> DomainPortfolio:
        model = self._mapper.to_persistence(entity)
        self._session.add(model)
        await self._session.flush()
        return self._mapper.to_domain(model)
```

### Command Handler (Application)
```python
from ...domain.repositories.portfolio_repository import IPortfolioRepository
from ...domain.entities.portfolio import Portfolio
from ..common import ICommandHandler

class CreatePortfolioCommandHandler(ICommandHandler[CreatePortfolioCommand, PortfolioDTO]):
    def __init__(self, portfolio_repo: IPortfolioRepository):
        self._portfolio_repo = portfolio_repo
    
    async def handle(self, command: CreatePortfolioCommand) -> PortfolioDTO:
        # 1. Cr√©er entit√© domaine
        portfolio = Portfolio(
            name=command.name,
            user_id=command.user_id,
            base_currency=Currency(command.currency)
        )
        
        # 2. Sauvegarder via repository
        saved_portfolio = await self._portfolio_repo.save(portfolio)
        
        # 3. Convertir en DTO
        return PortfolioMapper.to_dto(saved_portfolio)
```

### Router FastAPI (Infrastructure)
```python
from fastapi import APIRouter, Depends, HTTPException, status
from ..dependencies import get_portfolio_service, get_current_user

router = APIRouter(prefix="/api/v1/portfolios", tags=["portfolios"])

@router.post("/", response_model=PortfolioDTO)
async def create_portfolio(
    command: CreatePortfolioCommand,
    service: PortfolioService = Depends(get_portfolio_service),
    current_user: User = Depends(get_current_user)
) -> PortfolioDTO:
    """Cr√©er un nouveau portfolio."""
    command.user_id = current_user.id
    return await service.create_portfolio(command)
```

## Gestion des erreurs

### Exceptions m√©tier (Domain)
```python
class InsufficientFundsException(Exception):
    """Exception lev√©e quand les fonds sont insuffisants."""
    
class PositionLimitExceededException(Exception):
    """Exception lev√©e quand la limite de position est d√©pass√©e."""
```

### Exceptions Application
```python
class PortfolioNotFoundException(Exception):
    """Portfolio non trouv√©."""
    
class UserNotAuthorizedException(Exception):
    """Utilisateur non autoris√©."""
```

### Gestion HTTP (Infrastructure)
```python
@app.exception_handler(InsufficientFundsException)
async def insufficient_funds_handler(request: Request, exc: InsufficientFundsException):
    return JSONResponse(
        status_code=400,
        content={"error": "INSUFFICIENT_FUNDS", "message": str(exc)}
    )
```

## Cache Redis (Infrastructure)

### Configuration par type de donn√©es
- **Real-time data** : TTL 5 minutes
- **Daily data** : TTL 24 heures  
- **User sessions** : TTL 7 jours
- **API rate limiting** : TTL 1 heure

```python
# Pr√©fixes de cl√©s
CACHE_PREFIXES = {
    "market_data_rt": "md:rt:",      # Market data real-time
    "market_data_daily": "md:daily:", # Market data daily
    "portfolio": "portfolio:",        # Portfolio data
    "user_session": "session:",       # User sessions
}
```

## TimescaleDB (time-series)

### Tables optimis√©es
- `market_data` : Hypertable partitionn√©e par timestamp
- `portfolio_performance` : Historique des performances
- `technical_indicators` : Indicateurs techniques calcul√©s

```sql
-- Cr√©ation hypertable
SELECT create_hypertable('market_data', 'timestamp');

-- Index optimis√©s pour requ√™tes temporelles  
CREATE INDEX idx_market_data_symbol_time ON market_data (symbol, timestamp DESC);
```

## Tests (Structure obligatoire)

### Organisation tests/
```
tests/
‚îú‚îÄ‚îÄ unit/                    # Tests unitaires (rapides, isol√©s)
‚îÇ   ‚îú‚îÄ‚îÄ domain/             # Entities, Value Objects, Services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/       # Test_portfolio.py, test_user.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/       # Test_risk_calculator.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ value_objects/  # Test_money.py, test_price.py
‚îÇ   ‚îú‚îÄ‚îÄ application/        # Commands, Queries, Services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands/       # Test_create_portfolio_command.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queries/        # Test_get_portfolios_query.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services/       # Test_technical_analyzer.py
‚îÇ   ‚îî‚îÄ‚îÄ infrastructure/     # Repositories, Web, Persistence
‚îÇ       ‚îú‚îÄ‚îÄ persistence/    # Test repositories (avec DB en m√©moire)
‚îÇ       ‚îî‚îÄ‚îÄ web/           # Test routers FastAPI
‚îú‚îÄ‚îÄ integration/            # Tests d'int√©gration (DB, Redis, API)
‚îÇ   ‚îú‚îÄ‚îÄ persistence/        # Tests avec vraie DB
‚îÇ   ‚îú‚îÄ‚îÄ web/               # Tests endpoints complets
‚îÇ   ‚îî‚îÄ‚îÄ background/        # Tests Celery tasks
‚îî‚îÄ‚îÄ e2e/                   # Tests end-to-end (sc√©narios complets)
    ‚îî‚îÄ‚îÄ test_trading_scenarios.py
```

### Fixtures pytest essentielles
```python
# conftest.py
@pytest.fixture
async def db_session():
    """Session DB pour tests."""
    
@pytest.fixture
def portfolio_factory():
    """Factory pour cr√©er portfolios de test."""
    
@pytest.fixture
def mock_market_data_service():
    """Mock service donn√©es de march√©."""
```

## Authentification JWT

### Flux complet
1. **Login** : POST `/auth/login` ‚Üí Access + Refresh tokens
2. **Protected routes** : Header `Authorization: Bearer {access_token}`
3. **Refresh** : POST `/auth/refresh` ‚Üí Nouveaux tokens
4. **Logout** : POST `/auth/logout` ‚Üí Invalidation refresh token

### Services (Application layer)
```python
class JWTService:
    def generate_access_token(self, user_id: UUID) -> str
    def generate_refresh_token(self, user_id: UUID) -> str
    def validate_token(self, token: str) -> TokenPayload
    
class AuthenticationService:
    def authenticate(self, email: str, password: str) -> User
    def register(self, user_data: RegisterCommand) -> User
```

## Commandes de d√©veloppement

### D√©veloppement local
```bash
# D√©marrer environnement Docker
make dev

# Tests en continu
poetry run pytest-watch

# Coverage avec seuil minimum
poetry run pytest --cov=src --cov-fail-under=80

# Archivage donn√©es de march√©
make archive

# Backup base de donn√©es  
make backup
```

### D√©ploiement
```bash
# Build production
make build-prod

# Tests complets avant d√©ploiement
make test-all

# Deploy VPS
make deploy
```

## Pi√®ges √† √©viter absolument

### ‚ùå Anti-patterns
- **God objects** : Entit√©s avec trop de responsabilit√©s
- **Anemic domain** : Entit√©s sans logique m√©tier  
- **Repository leakage** : Logique SQL dans les services
- **DTO in domain** : DTOs utilis√©s dans la couche domaine
- **Mixed responsibilities** : Commands qui font du read

### ‚ö†Ô∏è Points d'attention
- **UTC partout** : Jamais de dates locales en base
- **Async consistency** : Utiliser `async with session` pour transactions
- **Cache invalidation** : Strat√©gie coh√©rente par type de donn√©es
- **Rate limiting YFinance** : Respecter les quotas API externes
- **Memory leaks** : Fermer les sessions SQLAlchemy
- **Circular imports** : Utiliser imports locaux dans les fonctions si n√©cessaire

## Monitoring & Logging

### Structured logging (structlog)
```python
import structlog

logger = structlog.get_logger(__name__)

# Dans les services
logger.info("portfolio_created", 
           portfolio_id=portfolio.id, 
           user_id=user.id,
           duration_ms=duration)
```

### M√©triques business
- Temps de r√©ponse par endpoint
- Nombre de portfolios cr√©√©s/jour  
- Erreurs API externes (YFinance)
- Usage cache Redis (hit rate)
- Performance requ√™tes TimescaleDB

---

*Derni√®re mise √† jour : 22 ao√ªt 2025*
