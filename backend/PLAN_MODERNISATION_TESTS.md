# Plan de Modernisation des Tests - BoursaVision ðŸ”„

> **Objectif**: Mettre Ã  jour l'architecture de tests pour correspondre Ã  la nouvelle architecture avec dependency injection et profiter de pytest 8.4.1

## ðŸ“‹ Analyse de l'Ã‰tat Actuel

### Points Faibles IdentifiÃ©s

1. **Configuration pytest.ini trop restrictive**
   - Beaucoup de fichiers ignorÃ©s (20+ ignores)
   - Pas d'utilisation des nouveautÃ©s pytest 8.4.1
   - Markers dÃ©finis mais pas exploitÃ©s

2. **Fixtures conftest.py basique**
   - Pas d'intÃ©gration avec dependency injection
   - Mocks manuels au lieu d'utiliser le container DI
   - Scope des fixtures non optimisÃ©

3. **Tests sans logique mÃ©tier claire**
   - Tests d'infrastructure mÃ©langÃ©s aux tests unitaires
   - Pas de sÃ©paration Domain/Application/Infrastructure
   - Coverage artificiellement gonflÃ©

4. **DÃ©pendances hardcodÃ©es**
   - Connexions directes aux services externes
   - Pas d'isolation entre tests
   - Tests lents (> 5 minutes pour la suite)

## ðŸŽ¯ Actions ConcrÃ¨tes Ã  Entreprendre

### 1. Refactoring Configuration (PrioritÃ©: HAUTE)

#### Nouveau pytest.ini
```ini
[pytest]
# Configuration moderne avec pytest 8.4.1
testpaths = tests
pythonpath = src
python_files = test_*.py *_test.py
python_classes = Test* *Tests  
python_functions = test_* should_*

# Asyncio natif avec pytest 8.4.1
asyncio_mode = auto
asyncio_default_fixture_loop_scope = session

# Performance et dÃ©veloppement
addopts = 
    -v
    --tb=short
    --strict-config
    --maxfail=1  # Stop au premier Ã©chec en dev
    --lf  # Last failed first
    --ff  # Failed first
    --durations=10
    --disable-warnings  # RÃ©duire le bruit

# Markers pour architecture propre
markers =
    # Performance
    fast: Tests < 100ms
    slow: Tests > 1s
    
    # Architecture layers  
    domain: Tests de la couche domain
    application: Tests de la couche application
    infrastructure: Tests de la couche infrastructure
    presentation: Tests de la couche presentation
    
    # Types de test
    unit: Tests unitaires avec mocks complets
    integration: Tests d'intÃ©gration avec vrais composants
    e2e: Tests end-to-end avec API complÃ¨te
    
    # DÃ©pendances
    database: NÃ©cessite une base de donnÃ©es
    external: Appelle des services externes
    container: Utilise le container DI

# Plus d'ignores - utiliser les markers Ã  la place
filterwarnings =
    ignore::DeprecationWarning
    ignore::PendingDeprecationWarning
```

### 2. Nouveau conftest.py avec DI (PrioritÃ©: HAUTE)

```python
"""Configuration pytest moderne avec Dependency Injection."""

import pytest
import asyncio
from pathlib import Path
import sys

# Import du container principal
backend_dir = Path(__file__).parent.parent
sys.path.insert(0, str(backend_dir / "src"))

from boursa_vision.containers.main_clean import MainContainer
from unittest.mock import AsyncMock, MagicMock


# =====================================
# CONTAINER FIXTURES (Session Scope)
# =====================================

@pytest.fixture(scope="session")
def event_loop():
    """Event loop pour toute la session de test."""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()


@pytest.fixture(scope="session")
def base_container():
    """Container de base pour tous les tests."""
    container = MainContainer()
    
    # Configuration test globale
    container.core.config.override({
        "environment": "testing",
        "database": {
            "url": "sqlite+aiosqlite:///:memory:",
            "echo": False
        },
        "redis": {
            "url": "redis://localhost:6379/15"
        }
    })
    
    return container


@pytest.fixture(scope="session")  
def test_container(base_container):
    """Container avec overrides pour environnement de test."""
    container = base_container
    
    # Mock des services externes au niveau session
    from tests.mocks.external_services import (
        MockYFinanceClient, 
        MockEmailService,
        MockCeleryApp
    )
    
    container.infrastructure.yfinance_client.override(MockYFinanceClient())
    container.infrastructure.email_service.override(MockEmailService())
    container.infrastructure.celery_app.override(MockCeleryApp())
    
    yield container
    
    # Cleanup session
    container.infrastructure.yfinance_client.reset_override()
    container.infrastructure.email_service.reset_override()
    container.infrastructure.celery_app.reset_override()


# =====================================
# FIXTURES PAR TYPE DE TEST
# =====================================

@pytest.fixture
def unit_container(test_container):
    """Container pour tests unitaires avec mocks complets."""
    container = test_container
    
    # Mock tous les repositories
    mock_portfolio_repo = AsyncMock()
    mock_investment_repo = AsyncMock()
    mock_user_repo = AsyncMock()
    
    container.repositories.portfolio_repository.override(mock_portfolio_repo)
    container.repositories.investment_repository.override(mock_investment_repo) 
    container.repositories.user_repository.override(mock_user_repo)
    
    # Mock les services domain
    mock_portfolio_service = MagicMock()
    mock_scoring_service = MagicMock()
    
    container.services.portfolio_service.override(mock_portfolio_service)
    container.services.scoring_service.override(mock_scoring_service)
    
    yield container
    
    # Cleanup
    container.repositories.portfolio_repository.reset_override()
    container.repositories.investment_repository.reset_override()
    container.repositories.user_repository.reset_override()
    container.services.portfolio_service.reset_override()
    container.services.scoring_service.reset_override()


@pytest.fixture
def integration_container(test_container):
    """Container pour tests d'intÃ©gration."""
    # Garde les vraies implÃ©mentations repositories
    # Mais mock les services externes
    yield test_container


@pytest.fixture
async def e2e_container(test_container):
    """Container pour tests E2E avec FastAPI."""
    # Application complÃ¨te avec tous les routers
    app = test_container.app()
    
    from httpx import AsyncClient
    async with AsyncClient(app=app, base_url="http://test") as client:
        yield client, test_container


# =====================================
# DATA FACTORIES
# =====================================

@pytest.fixture
def portfolio_data():
    """DonnÃ©es de portefeuille valides pour les tests."""
    return {
        "name": "Tech Portfolio",
        "description": "Technology investments",
        "user_id": "test-user-123"
    }


@pytest.fixture  
def investment_data():
    """DonnÃ©es d'investissement valides pour les tests."""
    return {
        "symbol": "AAPL",
        "name": "Apple Inc.",
        "quantity": 10,
        "purchase_price": 150.0,
        "current_price": 160.0
    }


@pytest.fixture
def user_data():
    """DonnÃ©es utilisateur valides pour les tests."""
    return {
        "id": "test-user-123",
        "email": "test@example.com", 
        "first_name": "Test",
        "last_name": "User"
    }


# =====================================
# UTILITIES
# =====================================

@pytest.fixture(autouse=True)
def reset_mocks():
    """Reset automatique des mocks entre chaque test."""
    yield
    # Cleanup automatique si nÃ©cessaire
    

def pytest_configure(config):
    """Configuration pytest au dÃ©marrage."""
    # Ajouter des markers dynamiques si nÃ©cessaire
    config.addinivalue_line("markers", "wip: Work in progress tests")


def pytest_collection_modifyitems(config, items):
    """Modifier la collection de tests pour optimisation."""
    # Trier les tests rapides en premier
    items.sort(key=lambda x: "fast" not in x.keywords)
```

### 3. Structure de Tests RÃ©organisÃ©e (PrioritÃ©: MOYENNE)

#### Nouveau dÃ©coupage par couche architecturale

```
tests/
â”œâ”€â”€ conftest.py                    # Configuration DI globale
â”œâ”€â”€ mocks/                         # Mocks rÃ©utilisables
â”‚   â”œâ”€â”€ external_services.py       # YFinance, Email, etc.
â”‚   â””â”€â”€ repositories.py            # Repository mocks
â”œâ”€â”€ fixtures/                      # Fixtures par domaine
â”‚   â”œâ”€â”€ container_fixtures.py      # DI containers
â”‚   â”œâ”€â”€ portfolio_fixtures.py      # Portfolio factories
â”‚   â””â”€â”€ market_data_fixtures.py    # Market data samples
â”œâ”€â”€ unit/                          # Tests unitaires purs
â”‚   â”œâ”€â”€ domain/                    # EntitÃ©s & Value Objects
â”‚   â”‚   â”œâ”€â”€ test_portfolio_entity.py
â”‚   â”‚   â””â”€â”€ test_investment_value_object.py
â”‚   â”œâ”€â”€ application/               # Use Cases & Services
â”‚   â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”‚   â”œâ”€â”€ test_create_portfolio_command.py
â”‚   â”‚   â”‚   â””â”€â”€ test_add_investment_command.py
â”‚   â”‚   â””â”€â”€ queries/
â”‚   â”‚       â””â”€â”€ test_portfolio_query_handler.py
â”‚   â””â”€â”€ infrastructure/            # Adapters (avec mocks)
â”‚       â”œâ”€â”€ test_portfolio_repository.py
â”‚       â””â”€â”€ test_yfinance_adapter.py
â”œâ”€â”€ integration/                   # Tests d'intÃ©gration
â”‚   â”œâ”€â”€ database/                  # Vraie DB (en mÃ©moire)
â”‚   â”‚   â””â”€â”€ test_portfolio_persistence.py
â”‚   â”œâ”€â”€ api/                       # Tests API layer
â”‚   â”‚   â””â”€â”€ test_portfolio_endpoints.py
â”‚   â””â”€â”€ services/                  # Services avec vraies implÃ©mentations
â”‚       â””â”€â”€ test_portfolio_service_integration.py
â”œâ”€â”€ e2e/                           # Tests end-to-end
â”‚   â”œâ”€â”€ scenarios/                 # User scenarios complets
â”‚   â”‚   â””â”€â”€ test_portfolio_management_scenario.py
â”‚   â””â”€â”€ api/                       # API tests complets
â”‚       â””â”€â”€ test_full_portfolio_workflow.py
â””â”€â”€ performance/                   # Tests de performance
    â””â”€â”€ test_portfolio_load.py
```

### 4. Exemples de Migration par Type

#### A. Migration Test Unitaire Domain

**AVANT (test existant problÃ©matique)**:
```python
def test_portfolio_creation():
    """Test basique sans logique claire."""
    portfolio = Portfolio("Test")
    assert portfolio.name == "Test"
```

**APRÃˆS (test moderne avec DI)**:
```python
@pytest.mark.unit
@pytest.mark.domain
def test_should_create_valid_portfolio_when_data_is_correct(portfolio_data):
    """Should create a valid portfolio when all required data is provided."""
    # Arrange
    expected_name = portfolio_data["name"]
    expected_description = portfolio_data["description"]
    
    # Act
    portfolio = Portfolio.create(portfolio_data)
    
    # Assert
    assert portfolio.is_valid()
    assert portfolio.name == expected_name
    assert portfolio.description == expected_description
    assert portfolio.total_value == 0.0
    assert len(portfolio.investments) == 0
```

#### B. Migration Test Application avec DI

**AVANT (dÃ©pendances hardcodÃ©es)**:
```python
def test_create_portfolio_use_case():
    """Test avec dÃ©pendances hardcodÃ©es."""
    db = TestDatabase() 
    repo = PortfolioRepository(db)
    use_case = CreatePortfolioUseCase(repo)
    
    result = use_case.execute({"name": "Test"})
    assert result is not None
```

**APRÃˆS (avec container DI)**:
```python
@pytest.mark.unit  
@pytest.mark.application
async def test_create_portfolio_command_should_create_and_return_portfolio(
    unit_container,
    portfolio_data
):
    """Should create portfolio through command handler when data is valid."""
    # Arrange
    command_handler = unit_container.application.create_portfolio_command()
    
    # Configure mock repository response
    expected_portfolio = Portfolio.create(portfolio_data)
    mock_repo = unit_container.repositories.portfolio_repository()
    mock_repo.save.return_value = expected_portfolio
    
    # Act
    result = await command_handler.execute(
        name=portfolio_data["name"],
        description=portfolio_data["description"],
        user_id=portfolio_data["user_id"]
    )
    
    # Assert
    assert result.success
    assert result.portfolio.name == portfolio_data["name"]
    mock_repo.save.assert_called_once()
```

#### C. Migration Test E2E avec FastAPI

**APRÃˆS (E2E moderne avec DI)**:
```python
@pytest.mark.e2e
@pytest.mark.asyncio
async def test_complete_portfolio_creation_workflow(
    e2e_container,
    portfolio_data,
    investment_data
):
    """Should handle complete portfolio creation and investment workflow."""
    client, container = e2e_container
    
    # Act 1: Create Portfolio
    response = await client.post("/api/v1/portfolios", json=portfolio_data)
    assert response.status_code == 201
    
    created_portfolio = response.json()
    portfolio_id = created_portfolio["id"]
    
    # Act 2: Add Investment  
    investment_payload = {**investment_data, "portfolio_id": portfolio_id}
    response = await client.post(
        f"/api/v1/portfolios/{portfolio_id}/investments",
        json=investment_payload
    )
    assert response.status_code == 201
    
    # Act 3: Retrieve Updated Portfolio
    response = await client.get(f"/api/v1/portfolios/{portfolio_id}")
    assert response.status_code == 200
    
    # Assert Final State
    final_portfolio = response.json()
    assert len(final_portfolio["investments"]) == 1
    assert final_portfolio["total_value"] > 0
```

### 5. Commandes de Migration

#### Ã‰tape 1: Backup et prÃ©paration
```bash
# Sauvegarder les tests actuels
git checkout -b backup-old-tests
git add tests/ && git commit -m "Backup: existing tests before migration"

# CrÃ©er branche de migration
git checkout develop
git checkout -b modernize-tests
```

#### Ã‰tape 2: Appliquer la nouvelle configuration
```bash
# Remplacer pytest.ini
cp pytest.ini pytest.ini.old
# [Appliquer la nouvelle configuration]

# Remplacer conftest.py
cp tests/conftest.py tests/conftest.py.old
# [Appliquer le nouveau conftest.py avec DI]
```

#### Ã‰tape 3: CrÃ©er les mocks et fixtures
```bash
mkdir -p tests/mocks tests/fixtures
# [CrÃ©er les nouveaux fichiers de mocks avec DI]
```

#### Ã‰tape 4: Migration progressive par couche
```bash
# Tests Domain d'abord (plus simples)
mkdir -p tests/unit/domain
# [Migrer tests domain]

# Tests Application ensuite  
mkdir -p tests/unit/application/{commands,queries}
# [Migrer tests application]

# Tests Infrastructure et E2E en dernier
mkdir -p tests/{integration,e2e}/{database,api,scenarios}
# [Migrer tests integration/e2e]
```

#### Ã‰tape 5: Validation et nettoyage
```bash
# Tester la nouvelle suite
poetry run pytest -m "fast and unit" --maxfail=5

# Coverage par couche
poetry run pytest --cov=src/boursa_vision/domain tests/unit/domain/
poetry run pytest --cov=src/boursa_vision/application tests/unit/application/

# Supprimer les anciens tests devenus obsolÃ¨tes
# [AprÃ¨s validation que les nouveaux tests couvrent tout]
```

## ðŸ“Š CritÃ¨res de SuccÃ¨s

### MÃ©triques Before/After

| MÃ©trique | Avant | Objectif AprÃ¨s |
|----------|-------|----------------|
| **Temps suite complÃ¨te** | ~5 min | < 2 min |
| **Temps tests unitaires** | ~2 min | < 30s |
| **Coverage Domain** | ? | > 95% |
| **Coverage Application** | ? | > 90% |
| **Nombre de tests ignored** | 20+ | 0 |
| **Tests flaky** | ? | 0 |

### Validation Quality Gates

- [ ] âœ… Tous les tests passent sans warnings
- [ ] âœ… Aucun test ignorÃ© (skip/ignore) 
- [ ] âœ… Coverage par couche respectÃ©
- [ ] âœ… Performance < seuils dÃ©finis
- [ ] âœ… Documentation Ã  jour
- [ ] âœ… Ã‰quipe formÃ©e aux nouveaux standards

## ðŸš€ Planning de Migration

**Semaine 1**: Configuration et infrastructure
- Nouveau pytest.ini et conftest.py  
- Mocks et fixtures avec DI
- Tests de validation infrastructure

**Semaine 2**: Migration couche Domain  
- Tests entitÃ©s et value objects
- Tests services domain purs
- Validation coverage Domain > 95%

**Semaine 3**: Migration couche Application
- Tests commandes et queries CQRS
- Tests use cases avec DI
- Validation coverage Application > 90%

**Semaine 4**: Migration Infrastructure et E2E
- Tests repositories avec vraie DB
- Tests API endpoints
- Tests scÃ©narios utilisateur complets

**Semaine 5**: Optimisation et documentation
- Tuning performance  
- Documentation finale
- Formation Ã©quipe

---

*Plan de migration crÃ©Ã© le: DÃ©cembre 2024*
*Statut: ðŸ“‹ PrÃªt pour exÃ©cution*
