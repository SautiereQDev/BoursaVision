"""
Advanced tests for OptimizedYFinanceClient - Priority #4
Testing main API methods and resilience patterns
"""

import pytest
from unittest.mock import Mock, MagicMock, patch, AsyncMock
from typing import Dict, Any, List, Optional
import pandas as pd
from datetime import datetime, timedelta
import asyncio
from concurrent.futures import ThreadPoolExecutor, Future

from boursa_vision.infrastructure.external.yfinance_client import (
    OptimizedYFinanceClient,
    YFinanceConfig,
    YFinanceError,
    YFinanceRateLimitError,
    YFinanceTimeoutError,
    RequestMetrics
)

try:
    from boursa_vision.infrastructure.cache import CacheConfig
except ImportError:
    # Mock CacheConfig if not available
    class CacheConfig:
        def __init__(self, host="localhost", port=6379, db=0):
            self.host = host
            self.port = port
            self.db = db


class TestOptimizedYFinanceClientMethods:
    """Test the main API methods of OptimizedYFinanceClient."""

    @pytest.fixture
    def mock_client(self):
        """Create a mock client with all dependencies mocked."""
        config = YFinanceConfig(
            max_requests_per_minute=60,
            enable_cache=False  # Disable cache for simpler testing
        )
        
        with patch.multiple(
            'boursa_vision.infrastructure.external.yfinance_client',
            yf=MagicMock(),
            AdaptiveRateLimiter=MagicMock(),
            CircuitBreaker=MagicMock(),
            RetryHandler=MagicMock(),
            RedisCache=MagicMock(),
            ThreadPoolExecutor=MagicMock(),
            AdaptiveCacheStrategy=MagicMock(),
        ) as mocks:
            client = OptimizedYFinanceClient(config)
            
            # Mock components with proper behavior
            client.rate_limiter = MagicMock()
            client.circuit_breaker = MagicMock()
            client.retry_handler = MagicMock()
            client.cache = None  # Cache disabled
            client.executor = MagicMock()
            
            # Configure mocks for success scenarios
            client.rate_limiter.acquire = MagicMock()
            client.circuit_breaker.call = MagicMock()
            client.retry_handler.execute = MagicMock()
            
            return client

    @pytest.fixture
    def mock_yfinance_ticker_data(self):
        """Sample yfinance ticker data."""
        return {
            'info': {
                'symbol': 'AAPL',
                'longName': 'Apple Inc.',
                'currentPrice': 150.0,
                'marketCap': 2500000000000,
                'dividendYield': 0.006
            }
        }

    @pytest.fixture
    def mock_historical_data(self):
        """Sample historical data as pandas DataFrame."""
        dates = pd.date_range(start='2023-01-01', end='2023-01-10', freq='D')
        return pd.DataFrame({
            'Open': [150.0, 151.0, 152.0, 151.5, 153.0, 152.5, 154.0, 153.5, 155.0, 154.5],
            'High': [151.0, 152.0, 153.0, 152.5, 154.0, 153.5, 155.0, 154.5, 156.0, 155.5],
            'Low': [149.0, 150.0, 151.0, 150.5, 152.0, 151.5, 153.0, 152.5, 154.0, 153.5],
            'Close': [150.5, 151.5, 152.5, 151.0, 153.5, 152.0, 154.5, 153.0, 155.5, 154.0],
            'Volume': [1000000, 1100000, 1050000, 980000, 1200000, 1150000, 1080000, 990000, 1250000, 1180000]
        }, index=dates)

    def test_get_stock_info_success(self, mock_client, mock_yfinance_ticker_data):
        """Test successful stock info retrieval."""
        # Arrange
        symbol = "AAPL"
        expected_info = mock_yfinance_ticker_data['info']
        
        # Mock yfinance ticker
        mock_ticker = MagicMock()
        mock_ticker.info = expected_info
        
        with patch('boursa_vision.infrastructure.external.yfinance_client.yf.Ticker') as mock_yf_ticker:
            mock_yf_ticker.return_value = mock_ticker
            mock_client.circuit_breaker.call.return_value = expected_info
            
            # Act
            result = mock_client.get_stock_info(symbol)
            
            # Assert
            assert result == expected_info
            mock_yf_ticker.assert_called_once_with(symbol)
            assert mock_client.metrics.successful_requests == 1

    def test_get_stock_info_cache_hit(self, mock_client, mock_yfinance_ticker_data):
        """Test cache hit scenario."""
        # Arrange
        symbol = "AAPL"
        expected_info = mock_yfinance_ticker_data['info']
        
        # Enable cache for this test
        mock_client.cache = MagicMock()
        mock_client.cache.get.return_value = expected_info
        
        # Act
        result = mock_client.get_stock_info(symbol, use_cache=True)
        
        # Assert
        assert result == expected_info
        assert mock_client.metrics.cache_hits == 1
        mock_client.cache.get.assert_called_once()

    def test_get_stock_info_cache_miss(self, mock_client, mock_yfinance_ticker_data):
        """Test cache miss scenario."""
        # Arrange
        symbol = "AAPL"
        expected_info = mock_yfinance_ticker_data['info']
        
        # Enable cache for this test
        mock_client.cache = MagicMock()
        mock_client.cache.get.return_value = None  # Cache miss
        
        mock_ticker = MagicMock()
        mock_ticker.info = expected_info
        
        with patch('boursa_vision.infrastructure.external.yfinance_client.yf.Ticker') as mock_yf_ticker:
            mock_yf_ticker.return_value = mock_ticker
            mock_client.circuit_breaker.call.return_value = expected_info
            
            # Act
            result = mock_client.get_stock_info(symbol, use_cache=True)
            
            # Assert
            assert result == expected_info
            assert mock_client.metrics.cache_misses == 1
            mock_client.cache.set.assert_called_once()

    def test_get_stock_info_api_error(self, mock_client):
        """Test API error handling."""
        # Arrange
        symbol = "INVALID"
        
        with patch('boursa_vision.infrastructure.external.yfinance_client.yf.Ticker') as mock_yf_ticker:
            mock_yf_ticker.side_effect = Exception("API Error")
            mock_client.circuit_breaker.call.side_effect = YFinanceError("API Error")
            
            # Act & Assert
            with pytest.raises(YFinanceError):
                mock_client.get_stock_info(symbol)
            
            assert mock_client.metrics.failed_requests == 1

    def test_get_historical_data_success(self, mock_client, mock_historical_data):
        """Test successful historical data retrieval."""
        # Arrange
        symbol = "AAPL"
        period = "1y"
        
        mock_ticker = MagicMock()
        mock_ticker.history.return_value = mock_historical_data
        
        with patch('boursa_vision.infrastructure.external.yfinance_client.yf.Ticker') as mock_yf_ticker:
            mock_yf_ticker.return_value = mock_ticker
            mock_client.circuit_breaker.call.return_value = mock_historical_data
            
            # Act
            result = mock_client.get_historical_data(symbol, period=period)
            
            # Assert
            assert result is not None
            assert isinstance(result, pd.DataFrame)
            assert len(result) == len(mock_historical_data)
            mock_ticker.history.assert_called_once_with(period=period, interval="1d")

    def test_get_historical_data_with_custom_params(self, mock_client, mock_historical_data):
        """Test historical data with custom parameters."""
        # Arrange
        symbol = "AAPL"
        start_date = datetime(2023, 1, 1)
        end_date = datetime(2023, 12, 31)
        interval = "1h"
        
        mock_ticker = MagicMock()
        mock_ticker.history.return_value = mock_historical_data
        
        with patch('boursa_vision.infrastructure.external.yfinance_client.yf.Ticker') as mock_yf_ticker:
            mock_yf_ticker.return_value = mock_ticker
            mock_client.circuit_breaker.call.return_value = mock_historical_data
            
            # Act
            result = mock_client.get_historical_data(
                symbol, 
                start=start_date, 
                end=end_date, 
                interval=interval
            )
            
            # Assert
            assert result is not None
            mock_ticker.history.assert_called_once_with(
                start=start_date, 
                end=end_date, 
                interval=interval
            )

    def test_get_multiple_stock_info_success(self, mock_client, mock_yfinance_ticker_data):
        """Test successful multiple stock info retrieval."""
        # Arrange
        symbols = ["AAPL", "GOOGL", "MSFT"]
        expected_info = mock_yfinance_ticker_data['info']
        
        # Mock concurrent execution
        mock_future = MagicMock()
        mock_future.result.return_value = expected_info
        mock_client.executor.submit.return_value = mock_future
        
        # Act
        results = mock_client.get_multiple_stock_info(symbols)
        
        # Assert
        assert len(results) == len(symbols)
        assert all(symbol in results for symbol in symbols)
        assert mock_client.executor.submit.call_count == len(symbols)

    def test_get_multiple_stock_info_partial_failure(self, mock_client, mock_yfinance_ticker_data):
        """Test multiple stock info with partial failures."""
        # Arrange
        symbols = ["AAPL", "INVALID", "MSFT"]
        expected_info = mock_yfinance_ticker_data['info']
        
        def mock_submit_side_effect(func, *args):
            mock_future = MagicMock()
            if "INVALID" in args:
                mock_future.result.side_effect = YFinanceError("Invalid symbol")
            else:
                mock_future.result.return_value = expected_info
            return mock_future
        
        mock_client.executor.submit.side_effect = mock_submit_side_effect
        
        # Act
        results = mock_client.get_multiple_stock_info(symbols)
        
        # Assert
        assert len(results) == 2  # Only successful results
        assert "AAPL" in results
        assert "MSFT" in results
        assert "INVALID" not in results


class TestOptimizedYFinanceClientRobustness:
    """Test resilience patterns and error handling."""

    @pytest.fixture
    def robust_client(self):
        """Create a client for robustness testing."""
        config = YFinanceConfig(
            max_requests_per_minute=60,
            enable_cache=True,
            circuit_breaker_failure_threshold=3,
            max_retries=3
        )
        
        with patch.multiple(
            'boursa_vision.infrastructure.external.yfinance_client',
            yf=MagicMock(),
            AdaptiveRateLimiter=MagicMock(),
            CircuitBreaker=MagicMock(),
            RetryHandler=MagicMock(),
            RedisCache=MagicMock(),
            ThreadPoolExecutor=MagicMock(),
            AdaptiveCacheStrategy=MagicMock(),
        ):
            client = OptimizedYFinanceClient(config)
            
            # Mock components
            client.rate_limiter = MagicMock()
            client.circuit_breaker = MagicMock()
            client.retry_handler = MagicMock()
            client.cache = MagicMock()
            client.executor = MagicMock()
            
            return client

    def test_rate_limit_error_handling(self, robust_client):
        """Test rate limit error handling."""
        # Arrange
        robust_client.rate_limiter.acquire.side_effect = YFinanceRateLimitError("Rate limit exceeded")
        
        # Act & Assert
        with pytest.raises(YFinanceRateLimitError):
            robust_client.get_stock_info("AAPL")

    def test_timeout_error_handling(self, robust_client):
        """Test timeout error handling."""
        # Arrange
        robust_client.circuit_breaker.call.side_effect = YFinanceTimeoutError("Timeout")
        
        # Act & Assert
        with pytest.raises(YFinanceTimeoutError):
            robust_client.get_stock_info("AAPL")

    def test_circuit_breaker_open(self, robust_client):
        """Test circuit breaker in open state."""
        # Arrange
        robust_client.circuit_breaker.call.side_effect = YFinanceError("Circuit breaker is open")
        
        # Act & Assert
        with pytest.raises(YFinanceError):
            robust_client.get_stock_info("AAPL")

    def test_retry_mechanism(self, robust_client):
        """Test retry mechanism on failures."""
        # Arrange
        symbol = "AAPL"
        expected_info = {"symbol": symbol, "price": 150.0}
        
        # First calls fail, then succeed
        def mock_internal_call(*args, **kwargs):
            mock_internal_call.call_count = getattr(mock_internal_call, 'call_count', 0) + 1
            if mock_internal_call.call_count < 3:
                raise YFinanceError("Invalid symbol")
            return expected_info
        
        with patch.object(robust_client, '_get_stock_info_internal', side_effect=mock_internal_call):
            # Act
            with pytest.raises(YFinanceError):
                robust_client.get_stock_info(symbol)
        
        # Verify retry attempts
        assert mock_internal_call.call_count >= 2

import pytest
from unittest.mock import Mock, patch, MagicMock
import pandas as pd

# Skip if module not available
try:
    from boursa_vision.infrastructure.external.yfinance_client import (
        YFinanceConfig,
        RequestMetrics,
        YFinanceError,
        YFinanceRateLimitError,
        YFinanceTimeoutError,
        OptimizedYFinanceClient,
    )
    HAS_YFINANCE_CLIENT = True
except ImportError:
    HAS_YFINANCE_CLIENT = False

pytestmark = pytest.mark.skipif(not HAS_YFINANCE_CLIENT, reason="YFinance client module not available")


class TestOptimizedYFinanceClientMethods:
    """Test main methods of OptimizedYFinanceClient."""

    @pytest.fixture
    def mock_client(self):
        """Create a mock client with all dependencies mocked."""
        config = YFinanceConfig(
            max_requests_per_minute=60,
            enable_cache=True,
        cache_config=CacheConfig(host="localhost", port=6379, db=0)
    )
    
    with patch.multiple(
        'boursa_vision.infrastructure.external.yfinance_client',
        yf=MagicMock(),
        AdaptiveRateLimiter=MagicMock(),
        CircuitBreaker=MagicMock(),
        RetryHandler=MagicMock(),
        RedisCache=MagicMock(),
        ThreadPoolExecutor=MagicMock(),
        AdaptiveCacheStrategy=MagicMock(),
    ) as mocks:
        # Configure cache mock
        cache_mock = MagicMock()
        mocks['RedisCache'].return_value = cache_mock
        
        client = OptimizedYFinanceClient(config)
        
        # Ensure cache is properly set
        client.cache = cache_mock
        
        return client

    def test_get_stock_info_success(self, mock_client):
        """Test successful stock info retrieval."""
        # Arrange
        client, mock_yf = mock_client
        symbol = "AAPL"
        expected_info = {
            'symbol': 'AAPL',
            'longName': 'Apple Inc.',
            'currentPrice': 150.0,
            'marketCap': 2500000000000,
            'volume': 50000000,
            'sector': 'Technology'
        }
        
        # Mock yfinance ticker
        mock_ticker = Mock()
        mock_ticker.info = expected_info
        mock_yf.Ticker.return_value = mock_ticker
        
        # Mock circuit breaker and cache
        client.circuit_breaker.call = Mock(return_value=expected_info)
        client.cache_strategy.get = Mock(return_value=None)  # Cache miss
        client.cache_strategy.set = Mock()

        # Act
        with patch.object(client, '_get_stock_info_internal') as mock_internal:
            mock_internal.return_value = expected_info
            result = client.get_stock_info(symbol)

        # Assert
        assert result == expected_info
        mock_internal.assert_called_once_with(symbol)

    def test_get_stock_info_with_cache_hit(self, mock_client):
        """Test stock info retrieval with cache hit."""
        # Arrange
        client, mock_yf = mock_client
        symbol = "AAPL"
        cached_info = {
            'symbol': 'AAPL',
            'longName': 'Apple Inc.',
            'currentPrice': 150.0,
            'cached': True
        }
        
        # Mock cache hit
        client.cache_strategy.get = Mock(return_value=cached_info)

        # Act
        with patch.object(client, '_get_stock_info_internal') as mock_internal:
            result = client.get_stock_info(symbol)

        # Assert
        assert result == cached_info
        mock_internal.assert_not_called()  # Should not call internal method on cache hit
        client.cache_strategy.get.assert_called_once()

    def test_get_stock_info_with_yfinance_error(self, mock_client):
        """Test stock info retrieval with YFinance error."""
        # Arrange
        client, mock_yf = mock_client
        symbol = "INVALID"
        
        # Mock empty response
        mock_ticker = Mock()
        mock_ticker.info = {}
        mock_yf.Ticker.return_value = mock_ticker
        
        client.cache_strategy.get = Mock(return_value=None)
        client.circuit_breaker.call = Mock(side_effect=Exception("No data"))

        # Act & Assert
        with pytest.raises(YFinanceError):
            client.get_stock_info(symbol)

    def test_get_stock_info_with_rate_limiting(self, mock_client):
        """Test stock info retrieval with rate limiting."""
        # Arrange
        client, mock_yf = mock_client
        symbol = "AAPL"
        
        # Mock rate limiting
        client.rate_limiter.acquire = Mock()
        client.cache_strategy.get = Mock(return_value=None)
        
        expected_info = {'symbol': 'AAPL', 'currentPrice': 150.0}
        
        # Act
        with patch.object(client, '_get_stock_info_internal') as mock_internal:
            mock_internal.return_value = expected_info
            result = client.get_stock_info(symbol)

        # Assert
        client.rate_limiter.acquire.assert_called_once()
        assert result == expected_info

    def test_get_historical_data_success(self, mock_client):
        """Test successful historical data retrieval."""
        # Arrange
        client, mock_yf = mock_client
        symbol = "AAPL"
        period = "1mo"
        interval = "1d"
        
        # Create test DataFrame
        expected_data = pd.DataFrame({
            'Open': [145.0, 146.0, 147.0],
            'High': [147.0, 148.0, 149.0],
            'Low': [144.0, 145.0, 146.0],
            'Close': [146.0, 147.0, 148.0],
            'Volume': [1000000, 1100000, 1200000]
        })
        
        # Mock yfinance ticker
        mock_ticker = Mock()
        mock_ticker.history.return_value = expected_data
        mock_yf.Ticker.return_value = mock_ticker
        
        # Mock components
        client.cache_strategy.get = Mock(return_value=None)
        client.cache_strategy.set = Mock()
        client.circuit_breaker.call = Mock(return_value=expected_data)

        # Act
        with patch.object(client, '_get_historical_data_internal') as mock_internal:
            mock_internal.return_value = expected_data
            result = client.get_historical_data(symbol, period, interval)

        # Assert
        pd.testing.assert_frame_equal(result, expected_data)
        mock_internal.assert_called_once_with(symbol, period, interval)

    def test_get_historical_data_empty_result(self, mock_client):
        """Test historical data retrieval with empty result."""
        # Arrange
        client, mock_yf = mock_client
        symbol = "INVALID"
        
        # Mock empty DataFrame
        empty_data = pd.DataFrame()
        mock_ticker = Mock()
        mock_ticker.history.return_value = empty_data
        mock_yf.Ticker.return_value = mock_ticker
        
        client.cache_strategy.get = Mock(return_value=None)
        client.circuit_breaker.call = Mock(side_effect=YFinanceError("No data"))

        # Act & Assert
        with pytest.raises(YFinanceError):
            client.get_historical_data(symbol, "1mo", "1d")

    def test_get_multiple_stock_info_success(self, mock_client):
        """Test successful multiple stock info retrieval."""
        # Arrange
        client, mock_yf = mock_client
        symbols = ["AAPL", "GOOGL", "MSFT"]
        
        # Expected results
        expected_results = [
            {'symbol': 'AAPL', 'currentPrice': 150.0},
            {'symbol': 'GOOGL', 'currentPrice': 2500.0},
            {'symbol': 'MSFT', 'currentPrice': 300.0}
        ]

        # Act
        with patch.object(client, 'get_stock_info') as mock_get_stock:
            mock_get_stock.side_effect = expected_results
            result = client.get_multiple_stock_info(symbols)

        # Assert
        assert len(result) == 3
        assert result == expected_results
        assert mock_get_stock.call_count == 3

    def test_get_multiple_stock_info_with_errors(self, mock_client):
        """Test multiple stock info with some errors."""
        # Arrange
        client, mock_yf = mock_client
        symbols = ["AAPL", "INVALID", "MSFT"]
        
        def mock_get_stock_side_effect(symbol):
            if symbol == "AAPL":
                return {'symbol': 'AAPL', 'currentPrice': 150.0}
            elif symbol == "INVALID":
                raise YFinanceError("Invalid symbol")
            elif symbol == "MSFT":
                return {'symbol': 'MSFT', 'currentPrice': 300.0}

        # Act
        with patch.object(client, 'get_stock_info') as mock_get_stock:
            mock_get_stock.side_effect = mock_get_stock_side_effect
            result = client.get_multiple_stock_info(symbols)

        # Assert
        # Should return only successful results
        assert len(result) == 2
        assert result[0]['symbol'] == 'AAPL'
        assert result[1]['symbol'] == 'MSFT'

    def test_get_multiple_stock_info_empty_list(self, mock_client):
        """Test multiple stock info with empty symbol list."""
        # Arrange
        client, mock_yf = mock_client
        symbols = []

        # Act
        result = client.get_multiple_stock_info(symbols)

        # Assert
        assert result == []

    def test_metrics_tracking_on_successful_request(self, mock_client):
        """Test that metrics are properly tracked on successful requests."""
        # Arrange
        client, mock_yf = mock_client
        initial_total = client.metrics.total_requests
        initial_successful = client.metrics.successful_requests
        
        expected_info = {'symbol': 'AAPL', 'currentPrice': 150.0}

        # Act
        with patch.object(client, '_get_stock_info_internal') as mock_internal:
            mock_internal.return_value = expected_info
            client.cache_strategy.get = Mock(return_value=None)
            client.get_stock_info("AAPL")

        # Assert
        assert client.metrics.total_requests == initial_total + 1
        assert client.metrics.successful_requests == initial_successful + 1

    def test_metrics_tracking_on_failed_request(self, mock_client):
        """Test that metrics are properly tracked on failed requests."""
        # Arrange
        client, mock_yf = mock_client
        initial_total = client.metrics.total_requests
        initial_failed = client.metrics.failed_requests
        
        client.cache_strategy.get = Mock(return_value=None)
        client.circuit_breaker.call = Mock(side_effect=YFinanceError("Error"))

        # Act
        with pytest.raises(YFinanceError):
            client.get_stock_info("INVALID")

        # Assert
        assert client.metrics.total_requests == initial_total + 1
        assert client.metrics.failed_requests == initial_failed + 1


class TestOptimizedYFinanceClientRobustness:
    """Test robustness and edge cases."""

    @pytest.fixture
    def robust_client(self):
        """Create client for robustness testing."""
        config = YFinanceConfig()
        
        with patch('boursa_vision.infrastructure.external.yfinance_client.yf') as mock_yf, \
             patch('boursa_vision.infrastructure.external.yfinance_client.ThreadPoolExecutor'), \
             patch.object(OptimizedYFinanceClient, '_init_rate_limiter'), \
             patch.object(OptimizedYFinanceClient, '_init_circuit_breaker'), \
             patch.object(OptimizedYFinanceClient, '_init_retry_handler'), \
             patch.object(OptimizedYFinanceClient, '_init_cache'):
            
            client = OptimizedYFinanceClient(config)
            client.rate_limiter = Mock()
            client.circuit_breaker = Mock()
            client.retry_handler = Mock()
            client.cache_strategy = Mock()
            
            yield client, mock_yf

    def test_rate_limit_error_handling(self, robust_client):
        """Test handling of rate limit errors."""
        # Arrange
        client, mock_yf = robust_client
        client.rate_limiter.acquire = Mock(side_effect=Exception("Rate limited"))
        
        # Act & Assert
        with pytest.raises(YFinanceRateLimitError):
            client.get_stock_info("AAPL")

    def test_timeout_error_handling(self, robust_client):
        """Test handling of timeout errors."""
        # Arrange
        client, mock_yf = robust_client
        client.cache_strategy.get = Mock(return_value=None)
        client.circuit_breaker.call = Mock(side_effect=TimeoutError("Timeout"))
        
        # Act & Assert
        with pytest.raises(YFinanceTimeoutError):
            client.get_stock_info("AAPL")

    def test_network_error_handling(self, robust_client):
        """Test handling of network errors."""
        # Arrange
        client, mock_yf = robust_client
        client.cache_strategy.get = Mock(return_value=None)
        client.circuit_breaker.call = Mock(side_effect=ConnectionError("Network error"))
        
        # Act & Assert
        with pytest.raises(YFinanceError):
            client.get_stock_info("AAPL")

    def test_invalid_symbol_handling(self, robust_client):
        """Test handling of invalid symbols."""
        # Arrange
        client, mock_yf = robust_client
        client.cache_strategy.get = Mock(return_value=None)
        
        # Mock ticker with invalid response
        mock_ticker = Mock()
        mock_ticker.info = None
        mock_yf.Ticker.return_value = mock_ticker
        
        # Act
        with patch.object(client, '_get_stock_info_internal') as mock_internal:
            mock_internal.side_effect = YFinanceError("Invalid symbol")
            
            # Act & Assert
            with pytest.raises(YFinanceError):
                client.get_stock_info("INVALID_SYMBOL_12345")

    def test_empty_symbol_handling(self, robust_client):
        """Test handling of empty or None symbols."""
        # Arrange
        client, mock_yf = robust_client
        
        # Act & Assert
        with pytest.raises((ValueError, YFinanceError)):
            client.get_stock_info("")
            
        with pytest.raises((ValueError, YFinanceError, TypeError)):
            client.get_stock_info(None)

    def test_circuit_breaker_open_state(self, robust_client):
        """Test behavior when circuit breaker is open."""
        # Arrange
        client, mock_yf = robust_client
        client.cache_strategy.get = Mock(return_value=None)
        client.circuit_breaker.call = Mock(side_effect=Exception("Circuit breaker open"))
        
        # Act & Assert
        with pytest.raises(YFinanceError):
            client.get_stock_info("AAPL")

    def test_cache_error_handling(self, robust_client):
        """Test handling of cache errors."""
        # Arrange
        client, mock_yf = robust_client
        client.cache_strategy.get = Mock(side_effect=Exception("Cache error"))
        
        expected_info = {'symbol': 'AAPL', 'currentPrice': 150.0}
        
        # Act - should fall back to direct fetch when cache fails
        with patch.object(client, '_get_stock_info_internal') as mock_internal:
            mock_internal.return_value = expected_info
            result = client.get_stock_info("AAPL")

        # Assert - should still work despite cache error
        assert result == expected_info

    def test_concurrent_request_handling(self, robust_client):
        """Test handling of concurrent requests."""
        # Arrange
        client, mock_yf = robust_client
        symbols = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA"]
        
        # Mock successful responses
        def mock_get_stock_side_effect(symbol):
            return {'symbol': symbol, 'currentPrice': 100.0}

        # Act
        with patch.object(client, 'get_stock_info') as mock_get_stock:
            mock_get_stock.side_effect = mock_get_stock_side_effect
            result = client.get_multiple_stock_info(symbols)

        # Assert
        assert len(result) == 5
        assert all(item['currentPrice'] == 100.0 for item in result)
        assert mock_get_stock.call_count == 5
